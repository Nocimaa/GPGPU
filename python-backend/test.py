#!/usr/bin/env python3
"""
Utility to run grid searches against the CUDA/CPU streaming experiment.
The script enumerates a set of parameter combinations, launches `stream`, and
records timing/exit status per configuration so you can compare how the
background-subtraction knobs affect quality or performance.
"""

import argparse
import itertools
import json
import os
import subprocess
import sys
import tempfile
import time
from pathlib import Path


DEFAULT_GRID = {
    "opening_size": [3, 5],
    "th_low": [3, 6],
    "th_high": [30, 45],
    "bg_sampling_rate": [250, 500],
    "bg_number_frame": [5, 10],
}


def parse_grid_override(value: str):
    if "=" not in value:
        raise argparse.ArgumentTypeError("Expected a KEY=val1,val2 list")
    name, values = value.split("=", 1)
    parsed = [int(v) for v in values.split(",") if v]
    if not parsed:
        raise argparse.ArgumentTypeError(f"No values provided for {name}")
    return name, parsed


def get_param_grid(overrides):
    grid = DEFAULT_GRID.copy()
    for name, values in overrides:
        grid[name] = values
    return grid


def build_command(stream_exe, mode, video_path, params, bg_uri, output_path):
    cmd = [str(stream_exe), f"--mode={mode}", str(video_path)]
    if bg_uri:
        cmd.append(f"bg={bg_uri}")
    for key, value in params.items():
        cmd.append(f"{key}={value}")
    if output_path:
        cmd.extend(["--output", str(output_path)])
    return cmd


def main():
    parser = argparse.ArgumentParser(description="Grid search runner for stream")
    parser.add_argument("--gpgpu-dir", type=Path, default=Path("../gpgpu-cuda"),
                        help="Path to the gpgpu-cuda project (contains build/stream)")
    parser.add_argument("--video", type=Path, default=Path("gpgpu-cuda/samples/ACET.mp4"),
                        help="Input video that stream will process")
    parser.add_argument("--modes", type=str, default="cpu",
                        help="Comma-separated list of modes to test (cpu,gpu)")
    parser.add_argument("--bg", type=Path, default=None,
                        help="Optional background image to pass with --bg")
    parser.add_argument("--output-dir", type=Path, default=Path("outputs"),
                        help="Directory where temporary outputs and the JSON log are written")
    parser.add_argument("--keep-output", action="store_true",
                        help="Keep the output mp4 files generated by each run (default is to delete them)")
    parser.add_argument("--dry-run", action="store_true",
                        help="Only print the generated commands without executing anything")
    parser.add_argument("--grid", action="append", default=[], type=parse_grid_override,
                        help="Override a grid dimension (ex: --grid opening_size=5,7)")
    parser.add_argument("--use-lib", action="store_true",
                        help="Invoke the shared python library instead of the CLI executable")
    args = parser.parse_args()

    stream_exe = args.gpgpu_dir / "build" / "stream"
    if not args.use_lib and not stream_exe.exists():
        parser.error(f"Executable not found: {stream_exe}")

    video_path = args.video
    if not video_path.exists():
        parser.error(f"Video file does not exist: {video_path}")

    grid = get_param_grid(args.grid)
    modes = [mode.strip() for mode in args.modes.split(",") if mode.strip()]
    combos = list(itertools.product(*(grid[key] for key in sorted(grid))))

    output_dir = args.output_dir
    output_dir.mkdir(parents=True, exist_ok=True)
    results_path = output_dir / "grid_results.json"

    if args.use_lib:
        try:
            import stream_engine
        except Exception as exc:  # pylint: disable=broad-except
            parser.error(f"Unable to import stream_engine module: {exc}")
        run_stream_lib = stream_engine.run_stream
    else:
        run_stream_lib = None

    records = []
    for idx, combo in enumerate(combos):
        params = dict(zip(sorted(grid), combo))
        for mode in modes:
            output_path = None
            if not args.dry_run:
                suffix = "_".join(f"{k}{v}" for k, v in params.items())
                temp_name = f"{mode}_{idx}_{suffix}.mp4"
                output_path = output_dir / temp_name

            cmd = build_command(
                stream_exe, mode, video_path, params, str(args.bg) if args.bg else None, output_path
            )

            record = {"mode": mode, "params": params, "command": " ".join(cmd)}
            if args.dry_run:
                print(record["command"])
                records.append(record)
                continue
            start = time.time()
            print(f"Running {idx + 1}/{len(combos)}: mode={mode} params={params}")
            if run_stream_lib:
                rc = run_stream_lib(
                    mode,
                    str(video_path),
                    output=str(output_path) if output_path else None,
                    background=str(args.bg) if args.bg else None,
                    opening_size=params["opening_size"],
                    th_low=params["th_low"],
                    th_high=params["th_high"],
                    bg_sampling_rate=params["bg_sampling_rate"],
                    bg_number_frame=params["bg_number_frame"],
                )
                duration = time.time() - start
                result = None
            else:
                result = subprocess.run(cmd, cwd=args.gpgpu_dir, capture_output=True, text=True)
                duration = time.time() - start
                rc = result.returncode

            record.update({
                "returncode": rc,
                "duration": duration,
                "stdout": result.stdout.strip() if result else "",
                "stderr": result.stderr.strip() if result else "",
                "output": str(output_path) if output_path else None,
            })
            records.append(record)
            print(f"Completed {idx + 1}/{len(combos)} mode={mode} params={params} rc={rc} duration={duration:.2f}s")
            if not args.keep_output and output_path and output_path.exists():
                output_path.unlink()

            if rc != 0:
                print(f"Command failed: {' '.join(cmd)}", file=sys.stderr)
                if result:
                    print(result.stderr, file=sys.stderr)
                break

    if records and not args.dry_run:
        with results_path.open("w") as f:
            json.dump(records, f, indent=2)
        print(f"Wrote grid results to {results_path}")


if __name__ == "__main__":
    main()
