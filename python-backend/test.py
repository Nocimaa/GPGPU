#!/usr/bin/env python3
"""
Utility to run grid searches against the CUDA/CPU streaming experiment.
The script enumerates a set of parameter combinations, launches `stream`, and
records timing/exit status per configuration so you can compare how the
background-subtraction knobs affect quality or performance.
"""

import argparse
import itertools
import json
import os
import subprocess
import sys
import tempfile
import time
from pathlib import Path


DEFAULT_GRID = {
    "opening_size": [3],
    "th_low": [5],
    "th_high": [40],
    "bg_sampling_rate": [400],
    "bg_number_frame": [15],
}


def parse_grid_override(value: str):
    if "=" not in value:
        raise argparse.ArgumentTypeError("Expected a KEY=val1,val2 list")
    name, values = value.split("=", 1)
    parsed = [int(v) for v in values.split(",") if v]
    if not parsed:
        raise argparse.ArgumentTypeError(f"No values provided for {name}")
    return name, parsed


def get_param_grid(overrides):
    grid = DEFAULT_GRID.copy()
    for name, values in overrides:
        grid[name] = values
    return grid


def build_command(stream_exe, mode, video_path, params, bg_uri, output_path, opt_flags=None):
    cmd = [str(stream_exe), f"--mode={mode}"]
    if opt_flags:
        cmd.extend(opt_flags)
    cmd.append(str(video_path))
    if bg_uri:
        cmd.append(f"bg={bg_uri}")
    for key, value in params.items():
        cmd.append(f"{key}={value}")
    if output_path:
        cmd.extend(["--output", str(output_path)])
    return cmd


def format_params(params):
    return ", ".join(f"{key}={value}" for key, value in sorted(params.items()))


def summarize_records(records, top_n=3):
    success = [record for record in records if record["returncode"] == 0]
    failures = [record for record in records if record["returncode"] != 0]
    if not success and not failures:
        return

    def sample_summary(record):
        base = f"{record['mode']} ({format_params(record['params'])})"
        duration = f"{record['duration']:.2f}s"
        return f"{base} â†’ rc={record['returncode']} duration={duration}"

    if success:
        best = sorted(success, key=lambda r: r["duration"])[:top_n]
        worst = sorted(success, key=lambda r: r["duration"], reverse=True)[:top_n]
        print("\nFastest successful runs:")
        for record in best:
            print("  " + sample_summary(record))
        print("\nSlowest successful runs:")
        for record in worst:
            print("  " + sample_summary(record))

    if failures:
        print("\nFailed runs:")
        for record in failures[:top_n]:
            print("  " + sample_summary(record))
        if len(failures) > top_n:
            print(f"  ...and {len(failures) - top_n} more failures")


def main():
    parser = argparse.ArgumentParser(description="Grid search runner for stream")
    parser.add_argument("--gpgpu-dir", type=Path, default=Path("../gpgpu-cuda"),
                        help="Path to the gpgpu-cuda project (contains build/stream)")
    parser.add_argument("--video", type=Path, default=Path("gpgpu-cuda/samples/ACET.mp4"),
                        help="Input video that stream will process")
    parser.add_argument("--modes", type=str, default="cpu",
                        help="Comma-separated list of modes to test (cpu,gpu)")
    parser.add_argument("--bg", type=Path, default=None,
                        help="Optional background image to pass with --bg")
    parser.add_argument("--output-dir", type=Path, default=Path("outputs"),
                        help="Directory where temporary outputs and the JSON log are written")
    parser.add_argument("--keep-output", action="store_true",
                        help="Keep the output mp4 files generated by each run (default is to delete them unless --use-lib)")
    parser.add_argument("--dry-run", action="store_true",
                        help="Only print the generated commands without executing anything")
    parser.add_argument("--grid", action="append", default=[], type=parse_grid_override,
                        help="Override a grid dimension (ex: --grid opening_size=5,7)")
    parser.add_argument("--use-lib", action="store_true",
                        help="Invoke the shared python library instead of the CLI executable")
    parser.add_argument("--gpu-diff", type=int, choices=[0, 1], default=1,
                        help="Toggle GPU diff kernel (0 or 1)")
    parser.add_argument("--gpu-hysteresis", type=int, choices=[0, 1], default=1,
                        help="Toggle GPU hysteresis")
    parser.add_argument("--gpu-morphology", type=int, choices=[0, 1], default=1,
                        help="Toggle GPU morphology")
    parser.add_argument("--gpu-background", type=int, choices=[0, 1], default=1,
                        help="Toggle GPU background update")
    parser.add_argument("--gpu-overlay", type=int, choices=[0, 1], default=1,
                        help="Toggle GPU overlay")
    parser.add_argument("--kernel-fusion", type=int, choices=[0, 1], default=0,
                        help="Toggle GPU kernel fusion")
    args = parser.parse_args()

    stream_exe = args.gpgpu_dir / "build" / "stream"
    if not args.use_lib and not stream_exe.exists():
        parser.error(f"Executable not found: {stream_exe}")

    video_path = args.video
    if not video_path.exists():
        parser.error(f"Video file does not exist: {video_path}")

    grid = get_param_grid(args.grid)
    modes = [mode.strip() for mode in args.modes.split(",") if mode.strip()]
    combos = list(itertools.product(*(grid[key] for key in sorted(grid))))

    opt_flags = [
        f"--gpu-diff={args.gpu_diff}",
        f"--gpu-hysteresis={args.gpu_hysteresis}",
        f"--gpu-morphology={args.gpu_morphology}",
        f"--gpu-background={args.gpu_background}",
        f"--gpu-overlay={args.gpu_overlay}",
        f"--kernel-fusion={args.kernel_fusion}",
    ]

    output_dir = args.output_dir
    output_dir.mkdir(parents=True, exist_ok=True)
    results_path = output_dir / "grid_results.json"

    if args.use_lib:
        try:
            import stream_engine
        except Exception as exc:  # pylint: disable=broad-except
            parser.error(f"Unable to import stream_engine module: {exc}")
        run_stream_lib = stream_engine.run_stream
    else:
        run_stream_lib = None

    records = []
    should_keep_output = args.keep_output or args.use_lib
    if args.use_lib and not args.keep_output:
        print("Keeping generated videos because --use-lib was requested.")
    for idx, combo in enumerate(combos):
        params = dict(zip(sorted(grid), combo))
        for mode in modes:
            output_path = None
            if not args.dry_run:
                suffix = "_".join(f"{k}{v}" for k, v in params.items())
                temp_name = f"{mode}_{idx}_{suffix}.mp4"
                output_path = output_dir / temp_name
            cmd = build_command(
                stream_exe,
                mode,
                video_path,
                params,
                str(args.bg) if args.bg else None,
                output_path,
                opt_flags=opt_flags,
            )

            record = {"mode": mode, "params": params, "command": " ".join(cmd)}
            if args.dry_run:
                print(record["command"])
                records.append(record)
                continue
            start = time.time()
            print(f"Running {idx + 1}/{len(combos)}: mode={mode} params={params}")
            if run_stream_lib:
                rc = run_stream_lib(
                    mode,
                    str(video_path),
                    output=str(output_path) if output_path else None,
                    background=str(args.bg) if args.bg else None,
                    opening_size=params["opening_size"],
                    th_low=params["th_low"],
                    th_high=params["th_high"],
                    bg_sampling_rate=params["bg_sampling_rate"],
                    bg_number_frame=params["bg_number_frame"],
                )
                duration = time.time() - start
                result = None
            else:
                result = subprocess.run(cmd, cwd=args.gpgpu_dir, capture_output=True, text=True)
                duration = time.time() - start
                rc = result.returncode

            record.update({
                "returncode": rc,
                "duration": duration,
                "stdout": result.stdout.strip() if result else "",
                "stderr": result.stderr.strip() if result else "",
                "output": str(output_path) if output_path else None,
            })
            records.append(record)
            print(f"Completed {idx + 1}/{len(combos)} mode={mode} params={params} rc={rc} duration={duration:.2f}s")
            if not should_keep_output and output_path and output_path.exists():
                output_path.unlink()

            if rc != 0:
                print(f"Command failed: {' '.join(cmd)}", file=sys.stderr)
                if result:
                    print(result.stderr, file=sys.stderr)
                break

    if records and not args.dry_run:
        with results_path.open("w") as f:
            json.dump(records, f, indent=2)
        print(f"Wrote grid results to {results_path}")
        summarize_records(records)


if __name__ == "__main__":
    main()
